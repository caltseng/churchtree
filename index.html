<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ChurchTree - Presbyterian Lineage (Phase 0)</title>
  <style>
    :root {
      --bg-1: #f6f1e8;
      --bg-2: #e8efe6;
      --ink: #2b2b2b;
      --muted: #6b6b6b;
      --accent: #9e4d2f;
      --panel: #fffdfa;
      --grid: rgba(120, 110, 100, 0.2);
      --edge: #6a776a;
      --edge-hover: #a5422c;
      --node-fill: #fffdf9;
      --node-stroke: #4b5a4a;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Palatino Linotype", "Book Antiqua", Palatino, serif;
      color: var(--ink);
      background:
        linear-gradient(135deg, rgba(255,255,255,0.6), rgba(255,255,255,0.2)),
        radial-gradient(circle at 20% 20%, #f7eadc 0%, transparent 55%),
        radial-gradient(circle at 80% 30%, #e3efe9 0%, transparent 50%),
        linear-gradient(180deg, var(--bg-1), var(--bg-2));
      min-height: 100vh;
    }

    header {
      padding: 22px 24px 10px 24px;
    }

    h1 {
      margin: 0 0 6px 0;
      font-size: 28px;
      letter-spacing: 0.4px;
    }

    p {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
    }

    #graph-wrap {
      padding: 12px 16px 24px 16px;
      position: relative;
    }

    #chart {
      width: 100%;
      height: 70vh;
      min-height: 520px;
      border-radius: 16px;
      background: rgba(255, 255, 255, 0.6);
      box-shadow: 0 6px 22px rgba(0,0,0,0.08);
      overflow: hidden;
      position: relative;
    }

    svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .controls {
      position: absolute;
      top: 16px;
      right: 22px;
      display: flex;
      gap: 8px;
      z-index: 5;
    }

    .control-btn {
      border: 1px solid #cdb7a8;
      background: #fffdfa;
      color: #2b2b2b;
      font-size: 16px;
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 3px 10px rgba(0,0,0,0.08);
    }

    .control-btn:hover {
      border-color: #a87f6b;
      color: #7b3a24;
    }

    .note {
      margin: 10px 16px 0 16px;
      padding: 10px 12px;
      background: var(--panel);
      border: 1px solid #d9c6b8;
      border-radius: 10px;
      font-size: 12.5px;
      color: var(--muted);
    }

    #tooltip {
      position: fixed;
      display: none;
      max-width: 320px;
      padding: 10px 12px;
      font-size: 13px;
      line-height: 1.35;
      color: #2c2c2c;
      background: #fffdfa;
      border: 1px solid #d9c6b8;
      border-radius: 10px;
      box-shadow: 0 8px 18px rgba(0,0,0,0.12);
      pointer-events: none;
      z-index: 9999;
    }

    #tooltip .title {
      font-weight: 600;
      color: var(--accent);
      margin-bottom: 4px;
    }

    #tooltip .meta {
      color: var(--muted);
    }

    .edge-label {
      paint-order: stroke;
      stroke: rgba(255, 253, 249, 0.9);
      stroke-width: 3px;
      cursor: pointer;
    }

    @media (max-width: 720px) {
      h1 { font-size: 22px; }
      #chart { min-height: 420px; }
    }
  </style>
</head>
<body>
  <header>
    <h1>ChurchTree - Presbyterian Lineage</h1>
    <p>Phase 0 static graph. Hover nodes or edges for details.</p>
  </header>

  <div id="graph-wrap">
    <div class="controls">
      <button class="control-btn" id="zoom-in" aria-label="Zoom in">+</button>
      <button class="control-btn" id="zoom-out" aria-label="Zoom out">-</button>
      <button class="control-btn" id="zoom-reset" aria-label="Reset zoom">Reset</button>
    </div>
    <div id="chart"></div>
  </div>

  <div class="note">
    Graph rendered with D3.js (BSD-3-Clause).
  </div>
  <div id="tooltip"></div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    function showError(message) {
      const chart = document.getElementById("chart");
      chart.innerHTML = "";
      const div = document.createElement("div");
      div.style.padding = "16px";
      div.style.color = "#9a5a45";
      div.textContent = message;
      chart.appendChild(div);
    }

    function buildEdgeTooltip(edge, fromNode, toNode) {
      const fromLabel = fromNode && fromNode.short_label ? fromNode.short_label : (fromNode ? fromNode.name : "");
      const toLabel = toNode && toNode.short_label ? toNode.short_label : (toNode ? toNode.name : "");
      const reasons = (edge.reasons || []).join(", ");
      const title = edge.name ? edge.name : `${fromLabel} -> ${toLabel}`;
      return `
        <div class="title">${title}</div>
        <div><em>${edge.type.toUpperCase()}</em> (${edge.year || "unknown"})</div>
        ${edge.description ? `<div>${edge.description}</div>` : ""}
        ${reasons ? `<div class="meta">Reasons: ${reasons}</div>` : ""}
      `;
    }

    function buildNodeTooltip(node) {
      const years = node.start_year ? `${node.start_year}${node.end_year ? `-${node.end_year}` : ""}` : "unknown";
      const distinctives = node.distinctives && node.distinctives.length
        ? node.distinctives.join(", ")
        : "Not yet captured";
      const sizeEstimate = node.size_estimate ? node.size_estimate : "Not yet captured";
      return `
        <div class="title">${node.name}</div>
        <div>${node.short_label || node.name} (${years})</div>
        ${node.region ? `<div class="meta">Region: ${node.region}</div>` : ""}
        ${node.notes ? `<div class="meta">Notes: ${node.notes}</div>` : ""}
        <div class="meta">Theological distinctives: ${distinctives}</div>
        <div class="meta">Size estimate: ${sizeEstimate}</div>
      `;
    }

    function renderGraph(data) {
      const nodes = Array.isArray(data.nodes) ? data.nodes : [];
      const edges = Array.isArray(data.edges) ? data.edges : [];

      if (!nodes.length) {
        showError("No data loaded. Check that data/data.js exists and is reachable.");
        return;
      }

      const nodeMap = new Map(nodes.map(n => [n.id, n]));
      const childToParent = new Map();
      edges.forEach(e => {
        if (!childToParent.has(e.to_id)) {
          childToParent.set(e.to_id, e.from_id);
        }
      });

      const rootIds = nodes
        .filter(n => !childToParent.has(n.id))
        .map(n => n.id);

      const root = {
        id: "__root__",
        name: "Root",
        children: rootIds.map(id => ({ id }))
      };

      const buildTree = (node) => {
        const dataNode = nodeMap.get(node.id);
        const children = edges
          .filter(e => e.from_id === node.id)
          .map(e => ({ id: e.to_id }));
        return {
          id: node.id,
          data: dataNode || node,
          children: children.length ? children.map(buildTree) : []
        };
      };

      const treeRoot = {
        id: root.id,
        data: root,
        children: root.children.map(buildTree)
      };

      const chart = document.getElementById("chart");
      chart.innerHTML = "";
      const width = chart.clientWidth;
      const height = chart.clientHeight;

      const svg = d3.select(chart)
        .append("svg")
        .attr("width", width)
        .attr("height", height);

      const g = svg.append("g");

      const years = nodes
        .map(n => n.start_year)
        .filter(y => typeof y === "number" && !Number.isNaN(y))
        .sort((a, b) => a - b);
      const minYear = years.length ? years[0] : 0;
      const maxYear = years.length ? years[years.length - 1] : minYear;
      const bucket = 25;
      const yearBuckets = [];
      for (let y = minYear; y <= maxYear; y += bucket) {
        yearBuckets.push(y);
      }

      const yScale = d3.scaleBand()
        .domain(yearBuckets)
        .range([60, height - 40])
        .paddingInner(0.2);

      g.selectAll(".grid")
        .data(yearBuckets)
        .enter()
        .append("line")
        .attr("class", "grid")
        .attr("x1", 40)
        .attr("x2", width - 20)
        .attr("y1", d => yScale(d))
        .attr("y2", d => yScale(d))
        .attr("stroke", "var(--grid)")
        .attr("stroke-width", 1);

      g.selectAll(".grid-label")
        .data(yearBuckets)
        .enter()
        .append("text")
        .attr("class", "grid-label")
        .attr("x", 6)
        .attr("y", d => yScale(d) - 6)
        .attr("fill", "var(--muted)")
        .attr("font-size", 11)
        .text(d => d);

      const tree = d3.tree()
        .nodeSize([180, 120]);

      const rootNode = d3.hierarchy(treeRoot, d => d.children);
      tree(rootNode);

      const allNodes = rootNode.descendants().filter(d => d.data.id !== "__root__");
      const allLinks = rootNode.links().filter(l => l.target.data.id !== "__root__");

      allNodes.forEach(d => {
        const year = d.data.data && typeof d.data.data.start_year === "number"
          ? d.data.data.start_year
          : minYear;
        const bucketYear = yearBuckets.find(y => year >= y && year < y + bucket) || yearBuckets[yearBuckets.length - 1];
        d.y = yScale(bucketYear);
      });

      const link = g.selectAll(".link")
        .data(allLinks)
        .enter()
        .append("path")
        .attr("class", "link")
        .attr("fill", "none")
        .attr("stroke", "var(--edge)")
        .attr("stroke-width", 2)
        .attr("d", d => {
          const sx = d.source.x + 60;
          const sy = d.source.y;
          const tx = d.target.x + 60;
          const ty = d.target.y;
          const mx = (sx + tx) / 2;
          return `M ${sx} ${sy} C ${mx} ${sy}, ${mx} ${ty}, ${tx} ${ty}`;
        });

      const edgeLabels = g.selectAll(".edge-label")
        .data(allLinks)
        .enter()
        .append("text")
        .attr("class", "edge-label")
        .attr("font-size", 12)
        .attr("fill", "var(--muted)")
        .attr("text-anchor", "middle")
        .attr("x", d => (d.source.x + d.target.x) / 2 + 60)
        .attr("y", d => (d.source.y + d.target.y) / 2 - 6)
        .text(d => {
          const target = d.target.data.data || {};
          const source = d.source.data.data || {};
          const edge = edges.find(e => e.from_id === source.id && e.to_id === target.id);
          return edge && edge.name ? edge.name : "";
        });

      const node = g.selectAll(".node")
        .data(allNodes)
        .enter()
        .append("g")
        .attr("class", "node")
        .attr("transform", d => `translate(${d.x}, ${d.y})`);

      node.append("rect")
        .attr("width", 170)
        .attr("height", 38)
        .attr("rx", 8)
        .attr("ry", 8)
        .attr("fill", "var(--node-fill)")
        .attr("stroke", "var(--node-stroke)")
        .attr("stroke-width", 1.2);

      node.append("text")
        .attr("x", 8)
        .attr("y", 16)
        .attr("font-size", 13)
        .attr("fill", "var(--ink)")
        .text(d => {
          const n = d.data.data || {};
          return n.short_label ? `${n.short_label} (${n.start_year || "?"})` : (n.name || "");
        });

      node.append("text")
        .attr("x", 8)
        .attr("y", 30)
        .attr("font-size", 11)
        .attr("fill", "var(--muted)")
        .text(d => (d.data.data && d.data.data.name) ? d.data.data.name : "");

      const tooltip = document.getElementById("tooltip");

      node.on("mousemove", (event, d) => {
        const n = d.data.data || {};
        tooltip.innerHTML = buildNodeTooltip(n);
        tooltip.style.display = "block";
        tooltip.style.left = `${event.clientX + 12}px`;
        tooltip.style.top = `${event.clientY + 12}px`;
      }).on("mouseleave", () => {
        tooltip.style.display = "none";
      });

      function showEdgeTooltip(event, d) {
        const target = d.target.data.data || {};
        const source = d.source.data.data || {};
        const edge = edges.find(e => e.from_id === source.id && e.to_id === target.id) || {};
        tooltip.innerHTML = buildEdgeTooltip(edge, source, target);
        tooltip.style.display = "block";
        tooltip.style.left = `${event.clientX + 12}px`;
        tooltip.style.top = `${event.clientY + 12}px`;
      }

      function hideEdgeTooltip() {
        tooltip.style.display = "none";
      }

      link.on("mousemove", (event, d) => {
        showEdgeTooltip(event, d);
        d3.select(event.currentTarget).attr("stroke", "var(--edge-hover)");
      }).on("mouseleave", (event) => {
        hideEdgeTooltip();
        d3.select(event.currentTarget).attr("stroke", "var(--edge)");
      });

      edgeLabels.on("mousemove", (event, d) => {
        showEdgeTooltip(event, d);
      }).on("mouseleave", () => {
        hideEdgeTooltip();
      });

      edgeLabels.raise();

      const zoom = d3.zoom()
        .scaleExtent([0.4, 2.2])
        .on("zoom", (event) => {
          g.attr("transform", event.transform);
        });

      svg.call(zoom);

      const zoomIn = document.getElementById("zoom-in");
      const zoomOut = document.getElementById("zoom-out");
      const zoomReset = document.getElementById("zoom-reset");

      zoomIn.addEventListener("click", () => {
        svg.transition().call(zoom.scaleBy, 1.2);
      });
      zoomOut.addEventListener("click", () => {
        svg.transition().call(zoom.scaleBy, 0.8);
      });
      zoomReset.addEventListener("click", () => {
        svg.transition().call(zoom.transform, d3.zoomIdentity);
      });
    }

    const dataScript = document.createElement("script");
    dataScript.src = `data/data.js?v=${Date.now()}`;
    dataScript.onload = () => {
      if (!window.CHURCHTREE_DATA) {
        showError("Loaded data/data.js, but window.CHURCHTREE_DATA is missing.");
        return;
      }
      renderGraph(window.CHURCHTREE_DATA);
    };
    dataScript.onerror = () => {
      const expected = new URL("data/data.js", window.location.href).href;
      showError(`Failed to load data/data.js. Expected at ${expected}`);
    };
    document.head.appendChild(dataScript);
  </script>
</body>
</html>
