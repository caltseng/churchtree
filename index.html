<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ChurchTree - Presbyterian Lineage (Phase 0)</title>
  <style>
    :root {
      --bg-1: #f6f1e8;
      --bg-2: #e8efe6;
      --ink: #2b2b2b;
      --muted: #6b6b6b;
      --accent: #9e4d2f;
      --panel: #fffdfa;
      --grid: rgba(120, 110, 100, 0.2);
      --edge: #6a776a;
      --edge-hover: #a5422c;
      --node-fill: #fffdf9;
      --node-stroke: #4b5a4a;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Palatino Linotype", "Book Antiqua", Palatino, serif;
      color: var(--ink);
      background:
        linear-gradient(135deg, rgba(255,255,255,0.6), rgba(255,255,255,0.2)),
        radial-gradient(circle at 20% 20%, #f7eadc 0%, transparent 55%),
        radial-gradient(circle at 80% 30%, #e3efe9 0%, transparent 50%),
        linear-gradient(180deg, var(--bg-1), var(--bg-2));
      min-height: 100vh;
    }

    header {
      padding: 22px 24px 10px 24px;
    }

    h1 {
      margin: 0 0 6px 0;
      font-size: 28px;
      letter-spacing: 0.4px;
    }

    p {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
    }

    #graph-wrap {
      padding: 12px 16px 24px 16px;
      position: relative;
      min-width: 1400px;
    }

    #chart {
      width: 1600px;
      height: 160vh;
      min-height: 1200px;
      border-radius: 16px;
      background: rgba(255, 255, 255, 0.6);
      box-shadow: 0 6px 22px rgba(0,0,0,0.08);
      overflow: hidden;
      position: relative;
    }

    svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .controls {
      position: absolute;
      top: 16px;
      right: 22px;
      display: flex;
      gap: 8px;
      z-index: 5;
    }

    .control-btn {
      border: 1px solid #cdb7a8;
      background: #fffdfa;
      color: #2b2b2b;
      font-size: 16px;
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 3px 10px rgba(0,0,0,0.08);
    }

    .control-btn:hover {
      border-color: #a87f6b;
      color: #7b3a24;
    }

    .note {
      margin: 10px 16px 0 16px;
      padding: 10px 12px;
      background: var(--panel);
      border: 1px solid #d9c6b8;
      border-radius: 10px;
      font-size: 12.5px;
      color: var(--muted);
    }

    #tooltip {
      position: fixed;
      display: none;
      max-width: 320px;
      padding: 10px 12px;
      font-size: 13px;
      line-height: 1.35;
      color: #2c2c2c;
      background: #fffdfa;
      border: 1px solid #d9c6b8;
      border-radius: 10px;
      box-shadow: 0 8px 18px rgba(0,0,0,0.12);
      pointer-events: none;
      z-index: 9999;
    }

    #tooltip .title {
      font-weight: 600;
      color: var(--accent);
      margin-bottom: 4px;
    }

    #tooltip .meta {
      color: var(--muted);
    }

    .edge-label {
      paint-order: stroke;
      stroke: rgba(255, 253, 249, 0.9);
      stroke-width: 3px;
      cursor: pointer;
    }

    @media (max-width: 720px) {
      h1 { font-size: 22px; }
      #chart { min-height: 420px; }
    }
  </style>
</head>
<body>
  <header>
    <h1>ChurchTree - Presbyterian Lineage</h1>
    <p>Phase 0 static graph. Hover nodes or edges for details.</p>
  </header>

  <div id="graph-wrap">
    <div class="controls">
      <button class="control-btn" id="zoom-in" aria-label="Zoom in">+</button>
      <button class="control-btn" id="zoom-out" aria-label="Zoom out">-</button>
      <button class="control-btn" id="zoom-reset" aria-label="Reset zoom">Reset</button>
    </div>
    <div id="chart"></div>
  </div>

  <div class="note">
    Graph rendered with D3.js (BSD-3-Clause).
  </div>
  <div id="tooltip"></div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    function showError(message) {
      const chart = document.getElementById("chart");
      chart.innerHTML = "";
      const div = document.createElement("div");
      div.style.padding = "16px";
      div.style.color = "#9a5a45";
      div.textContent = message;
      chart.appendChild(div);
    }

    function buildEdgeTooltip(edge, fromNode, toNode) {
      const fromLabel = fromNode && fromNode.short_label ? fromNode.short_label : (fromNode ? fromNode.name : "");
      const toLabel = toNode && toNode.short_label ? toNode.short_label : (toNode ? toNode.name : "");
      const reasons = (edge.reasons || []).join(", ");
      const title = edge.name ? edge.name : `${fromLabel} -> ${toLabel}`;
      return `
        <div class="title">${title}</div>
        <div><em>${edge.type.toUpperCase()}</em> (${edge.year || "unknown"})</div>
        ${edge.description ? `<div>${edge.description}</div>` : ""}
        ${reasons ? `<div class="meta">Reasons: ${reasons}</div>` : ""}
      `;
    }

    function buildNodeTooltip(node) {
      const years = node.start_year ? `${node.start_year}${node.end_year ? `-${node.end_year}` : ""}` : "unknown";
      const distinctives = node.distinctives && node.distinctives.length
        ? node.distinctives.join(", ")
        : "Not yet captured";
      const sizeEstimate = node.size_estimate ? node.size_estimate : "Not yet captured";
      return `
        <div class="title">${node.name}</div>
        <div>${node.short_label || node.name} (${years})</div>
        ${node.region ? `<div class="meta">Region: ${node.region}</div>` : ""}
        ${node.notes ? `<div class="meta">Notes: ${node.notes}</div>` : ""}
        <div class="meta">Theological distinctives: ${distinctives}</div>
        <div class="meta">Size estimate: ${sizeEstimate}</div>
      `;
    }

    function renderGraph(data) {
      const nodes = Array.isArray(data.nodes) ? data.nodes : [];
      const edges = Array.isArray(data.edges) ? data.edges : [];

      if (!nodes.length) {
        showError("No data loaded. Check that data/data.js exists and is reachable.");
        return;
      }

      const nodeData = nodes.map(n => ({ ...n }));
      const nodeMap = new Map(nodeData.map(n => [n.id, n]));
      const parentInfo = new Map();
      edges.forEach(e => {
        const parent = nodeMap.get(e.from_id);
        if (!parent) return;
        const info = {
          year: typeof parent.start_year === "number" ? parent.start_year : 9999,
          name: parent.name || ""
        };
        const current = parentInfo.get(e.to_id);
        if (!current || info.year < current.year || (info.year === current.year && info.name < current.name)) {
          parentInfo.set(e.to_id, info);
        }
      });

      const chart = document.getElementById("chart");
      chart.innerHTML = "";
      const width = chart.clientWidth;
      const height = chart.clientHeight;

      const svg = d3.select(chart)
        .append("svg")
        .attr("width", width)
        .attr("height", height);

      const g = svg.append("g");

      const years = nodes
        .map(n => n.start_year)
        .filter(y => typeof y === "number" && !Number.isNaN(y))
        .sort((a, b) => a - b);
      const minYear = years.length ? years[0] : 0;
      const maxYear = years.length ? years[years.length - 1] : minYear;
      const bucket = 25;
      const startTick = Math.floor(minYear / bucket) * bucket;
      const endTick = Math.ceil(maxYear / bucket) * bucket;
      const yearTicks = [];
      for (let y = startTick; y <= endTick; y += bucket) {
        yearTicks.push(y);
      }

      const yScale = d3.scaleLinear()
        .domain([startTick, endTick])
        .range([60, height - 40]);

      g.selectAll(".grid")
        .data(yearTicks)
        .enter()
        .append("line")
        .attr("class", "grid")
        .attr("x1", 40)
        .attr("x2", width - 20)
        .attr("y1", d => yScale(d))
        .attr("y2", d => yScale(d))
        .attr("stroke", "var(--grid)")
        .attr("stroke-width", 1);

      g.selectAll(".grid-label")
        .data(yearTicks)
        .enter()
        .append("text")
        .attr("class", "grid-label")
        .attr("x", 6)
        .attr("y", d => yScale(d) - 6)
        .attr("fill", "var(--muted)")
        .attr("font-size", 11)
        .text(d => d);

      function bucketForYear(year) {
        if (typeof year !== "number" || Number.isNaN(year)) {
          return yearTicks[0];
        }
        return yearTicks.find(y => year >= y && year < y + bucket) || yearTicks[yearTicks.length - 1];
      }

      const bucketGroups = new Map();
      nodeData.forEach(n => {
        n._bucket = bucketForYear(n.start_year);
        if (!bucketGroups.has(n._bucket)) {
          bucketGroups.set(n._bucket, []);
        }
        bucketGroups.get(n._bucket).push(n);
      });

      bucketGroups.forEach(group => {
        group.sort((a, b) => {
          const ap = parentInfo.get(a.id);
          const bp = parentInfo.get(b.id);
          const apYear = ap ? ap.year : 9999;
          const bpYear = bp ? bp.year : 9999;
          if (apYear !== bpYear) return apYear - bpYear;
          const apName = ap ? ap.name : "";
          const bpName = bp ? bp.name : "";
          if (apName !== bpName) return apName.localeCompare(bpName);
          const ay = typeof a.start_year === "number" ? a.start_year : 0;
          const by = typeof b.start_year === "number" ? b.start_year : 0;
          return ay - by || a.name.localeCompare(b.name);
        });
      });

      function assignTargetX(group) {
        const spacing = Math.max(200, (width - 240) / (group.length + 1));
        group.forEach((n, idx) => {
          n._targetX = 120 + spacing * (idx + 1);
          n.x = n._targetX;
          const year = typeof n.start_year === "number" ? n.start_year : minYear;
          n.y = yScale(year);
        });
      }

      bucketGroups.forEach(assignTargetX);

      const parentX = new Map();
      nodeData.forEach(n => {
        const parents = edges.filter(e => e.to_id === n.id).map(e => nodeMap.get(e.from_id)).filter(Boolean);
        if (!parents.length) return;
        const avg = parents.reduce((sum, p) => sum + (p._targetX || width / 2), 0) / parents.length;
        parentX.set(n.id, avg);
      });

      bucketGroups.forEach(group => {
        group.sort((a, b) => {
          const ax = parentX.get(a.id);
          const bx = parentX.get(b.id);
          if (ax !== undefined && bx !== undefined && ax !== bx) return ax - bx;
          if (ax !== undefined && bx === undefined) return -1;
          if (ax === undefined && bx !== undefined) return 1;
          const ay = typeof a.start_year === "number" ? a.start_year : 0;
          const by = typeof b.start_year === "number" ? b.start_year : 0;
          return ay - by || a.name.localeCompare(b.name);
        });
        assignTargetX(group);
      });

      const links = edges
        .map(e => ({ ...e, source: e.from_id, target: e.to_id }))
        .filter(e => nodeData.some(n => n.id === e.source) && nodeData.some(n => n.id === e.target));

      const simulation = d3.forceSimulation(nodeData)
        .force("link", d3.forceLink(links).id(d => d.id).distance(260).strength(0.7))
        .force("x", d3.forceX(d => d._targetX || width / 2).strength(0.5))
        .force("collide", d3.forceCollide(115))
        .stop();

      for (let i = 0; i < 260; i += 1) {
        simulation.tick();
      }

      nodeData.forEach(d => {
        const year = typeof d.start_year === "number" ? d.start_year : minYear;
        d.y = yScale(year);
      });

      function edgeColor(edge) {
        if (edge.type === "merge" || edge.type === "origin" || edge.type === "continuation") return "#2b6cb0";
        if (edge.type === "split") return "#6b46c1";
        return "var(--edge)";
      }

      const link = g.selectAll(".link")
        .data(links)
        .enter()
        .append("path")
        .attr("class", "link")
        .attr("fill", "none")
        .attr("stroke", d => edgeColor(d))
        .attr("stroke-width", 2)
        .attr("d", d => {
          const sx = d.source.x + 60;
          const sy = d.source.y;
          const tx = d.target.x + 60;
          const ty = d.target.y;
          const mx = (sx + tx) / 2;
          return `M ${sx} ${sy} C ${mx} ${sy}, ${mx} ${ty}, ${tx} ${ty}`;
        });

      link.each(function(d) {
        d._pathEl = this;
      });

      const edgeLabels = g.selectAll(".edge-label")
        .data(links)
        .enter()
        .append("text")
        .attr("class", "edge-label")
        .attr("font-size", 12)
        .attr("fill", "var(--muted)")
        .attr("text-anchor", "middle")
        .attr("x", d => (d.source.x + d.target.x) / 2 + 60)
        .attr("y", d => (d.source.y + d.target.y) / 2 - 6)
        .text(d => d.name || "");

      const node = g.selectAll(".node")
        .data(nodeData)
        .enter()
        .append("g")
        .attr("class", "node")
        .attr("transform", d => `translate(${d.x}, ${d.y})`);

      node.append("rect")
        .attr("width", 190)
        .attr("height", 44)
        .attr("rx", 8)
        .attr("ry", 8)
        .attr("fill", "var(--node-fill)")
        .attr("stroke", "var(--node-stroke)")
        .attr("stroke-width", 1.2);

      node.append("text")
        .attr("x", 8)
        .attr("y", 18)
        .attr("font-size", 13)
        .attr("fill", "var(--ink)")
        .text(d => {
          return d.short_label ? `${d.short_label} (${d.start_year || "?"})` : (d.name || "");
        });

      node.append("text")
        .attr("x", 8)
        .attr("y", 34)
        .attr("font-size", 11)
        .attr("fill", "var(--muted)")
        .text(d => d.name || "");

      const tooltip = document.getElementById("tooltip");

      node.on("mousemove", (event, d) => {
        tooltip.innerHTML = buildNodeTooltip(d);
        tooltip.style.display = "block";
        tooltip.style.left = `${event.clientX + 12}px`;
        tooltip.style.top = `${event.clientY + 12}px`;
      }).on("mouseleave", () => {
        tooltip.style.display = "none";
      });

      function showEdgeTooltip(event, d) {
        const target = d.target || {};
        const source = d.source || {};
        tooltip.innerHTML = buildEdgeTooltip(d, source, target);
        tooltip.style.display = "block";
        tooltip.style.left = `${event.clientX + 12}px`;
        tooltip.style.top = `${event.clientY + 12}px`;
      }

      function hideEdgeTooltip() {
        tooltip.style.display = "none";
      }

      link.on("mousemove", (event, d) => {
        showEdgeTooltip(event, d);
        d3.select(event.currentTarget).attr("stroke", "var(--edge-hover)");
      }).on("mouseleave", (event, d) => {
        hideEdgeTooltip();
        d3.select(event.currentTarget).attr("stroke", edgeColor(d));
      });

      edgeLabels.on("mousemove", (event, d) => {
        showEdgeTooltip(event, d);
        if (d._pathEl) {
          d3.select(d._pathEl).attr("stroke", "var(--edge-hover)");
        }
      }).on("mouseleave", (event, d) => {
        hideEdgeTooltip();
        if (d && d._pathEl) {
          d3.select(d._pathEl).attr("stroke", edgeColor(d));
        }
      });

      edgeLabels.raise();

      const zoom = d3.zoom()
        .scaleExtent([0.4, 2.2])
        .on("zoom", (event) => {
          g.attr("transform", event.transform);
        });

      svg.call(zoom);

      const zoomIn = document.getElementById("zoom-in");
      const zoomOut = document.getElementById("zoom-out");
      const zoomReset = document.getElementById("zoom-reset");

      zoomIn.addEventListener("click", () => {
        svg.transition().call(zoom.scaleBy, 1.2);
      });
      zoomOut.addEventListener("click", () => {
        svg.transition().call(zoom.scaleBy, 0.8);
      });
      zoomReset.addEventListener("click", () => {
        svg.transition().call(zoom.transform, d3.zoomIdentity);
      });
    }

    const dataScript = document.createElement("script");
    dataScript.src = `data/data.js?v=${Date.now()}`;
    dataScript.onload = () => {
      if (!window.CHURCHTREE_DATA) {
        showError("Loaded data/data.js, but window.CHURCHTREE_DATA is missing.");
        return;
      }
      renderGraph(window.CHURCHTREE_DATA);
    };
    dataScript.onerror = () => {
      const expected = new URL("data/data.js", window.location.href).href;
      showError(`Failed to load data/data.js. Expected at ${expected}`);
    };
    document.head.appendChild(dataScript);
  </script>
</body>
</html>
