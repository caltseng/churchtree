<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ChurchTree - Presbyterian Lineage (Phase 0)</title>
  <style>
    :root {
      --bg-1: #f6f1e8;
      --bg-2: #e8efe6;
      --ink: #2b2b2b;
      --muted: #6b6b6b;
      --accent: #9e4d2f;
      --panel: #fffdfa;
      --grid: rgba(120, 110, 100, 0.2);
      --edge: #6a776a;
      --edge-hover: #a5422c;
      --node-fill: #fffdf9;
      --node-stroke: #4b5a4a;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Palatino Linotype", "Book Antiqua", Palatino, serif;
      color: var(--ink);
      background:
        linear-gradient(135deg, rgba(255,255,255,0.6), rgba(255,255,255,0.2)),
        radial-gradient(circle at 20% 20%, #f7eadc 0%, transparent 55%),
        radial-gradient(circle at 80% 30%, #e3efe9 0%, transparent 50%),
        linear-gradient(180deg, var(--bg-1), var(--bg-2));
      min-height: 100vh;
    }

    header {
      padding: 22px 24px 10px 24px;
    }

    h1 {
      margin: 0 0 6px 0;
      font-size: 28px;
      letter-spacing: 0.4px;
    }

    p {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
    }

    #graph-wrap {
      padding: 12px 16px 24px 16px;
      position: relative;
      min-width: 1400px;
      overflow-x: auto;
    }

    #chart {
      width: 1600px;
      height: 320vh;
      min-height: 2400px;
      border-radius: 16px;
      background: rgba(255, 255, 255, 0.6);
      box-shadow: 0 6px 22px rgba(0,0,0,0.08);
      overflow: hidden;
      position: relative;
    }

    #y-axis {
      position: sticky;
      left: 0;
      top: 0;
      width: 60px;
      height: 100%;
      z-index: 6;
      pointer-events: none;
      background: linear-gradient(90deg, rgba(246, 241, 232, 0.98), rgba(246, 241, 232, 0.6) 70%, rgba(246, 241, 232, 0));
    }

    svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .controls {
      position: fixed;
      top: 16px;
      right: 22px;
      display: flex;
      gap: 8px;
      z-index: 5;
    }

    .control-btn {
      border: 1px solid #cdb7a8;
      background: #fffdfa;
      color: #2b2b2b;
      font-size: 16px;
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 3px 10px rgba(0,0,0,0.08);
    }

    .control-btn:hover {
      border-color: #a87f6b;
      color: #7b3a24;
    }

    .note {
      margin: 10px 16px 0 16px;
      padding: 10px 12px;
      background: var(--panel);
      border: 1px solid #d9c6b8;
      border-radius: 10px;
      font-size: 12.5px;
      color: var(--muted);
    }

    #tooltip {
      position: fixed;
      display: none;
      max-width: 320px;
      padding: 10px 12px;
      font-size: 13px;
      line-height: 1.35;
      color: #2c2c2c;
      background: #fffdfa;
      border: 1px solid #d9c6b8;
      border-radius: 10px;
      box-shadow: 0 8px 18px rgba(0,0,0,0.12);
      pointer-events: none;
      z-index: 9999;
    }

    #tooltip .title {
      font-weight: 600;
      color: var(--accent);
      margin-bottom: 4px;
    }

    #tooltip .meta {
      color: var(--muted);
    }

    .edge-label {
      paint-order: stroke;
      stroke: rgba(255, 253, 249, 0.9);
      stroke-width: 3px;
      cursor: pointer;
    }

    @media (max-width: 720px) {
      h1 { font-size: 22px; }
      #chart { min-height: 420px; }
    }
  </style>
</head>
<body>
  <header>
    <h1>ChurchTree - Presbyterian Lineage</h1>
    <p>Phase 0 static graph. Hover nodes or edges for details.</p>
  </header>

  <div id="graph-wrap">
    <div class="controls">
      <button class="control-btn" id="zoom-in" aria-label="Zoom in">+</button>
      <button class="control-btn" id="zoom-out" aria-label="Zoom out">-</button>
      <button class="control-btn" id="zoom-reset" aria-label="Reset zoom">Reset</button>
    </div>
    <div id="y-axis"></div>
    <div id="chart"></div>
  </div>

  <div class="note">
    Graph rendered with D3.js (BSD-3-Clause).
  </div>
  <div id="tooltip"></div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    function showError(message) {
      const chart = document.getElementById("chart");
      chart.innerHTML = "";
      const div = document.createElement("div");
      div.style.padding = "16px";
      div.style.color = "#9a5a45";
      div.textContent = message;
      chart.appendChild(div);
    }

    function buildEdgeTooltip(edge, fromNode, toNode) {
      const fromLabel = fromNode && fromNode.short_label ? fromNode.short_label : (fromNode ? fromNode.name : "");
      const toLabel = toNode && toNode.short_label ? toNode.short_label : (toNode ? toNode.name : "");
      const reasons = (edge.reasons || []).join(", ");
      const title = edge.name ? edge.name : `${fromLabel} -> ${toLabel}`;
      return `
        <div class="title">${title}</div>
        <div><em>${edge.type.toUpperCase()}</em> (${edge.year || "unknown"})</div>
        ${edge.description ? `<div>${edge.description}</div>` : ""}
        ${reasons ? `<div class="meta">Reasons: ${reasons}</div>` : ""}
      `;
    }

    function buildNodeTooltip(node) {
      const years = node.start_year ? `${node.start_year}${node.end_year ? `-${node.end_year}` : ""}` : "unknown";
      const distinctives = node.distinctives && node.distinctives.length
        ? node.distinctives.join(", ")
        : "Not yet captured";
      const sizeEstimate = node.size_estimate ? node.size_estimate : "Not yet captured";
      return `
        <div class="title">${node.name}</div>
        <div>${node.short_label || node.name} (${years})</div>
        ${node.region ? `<div class="meta">Region: ${node.region}</div>` : ""}
        ${node.notes ? `<div class="meta">Notes: ${node.notes}</div>` : ""}
        <div class="meta">Theological distinctives: ${distinctives}</div>
        <div class="meta">Size estimate: ${sizeEstimate}</div>
      `;
    }

    function renderGraph(data) {
      const nodes = Array.isArray(data.nodes) ? data.nodes : [];
      const edges = Array.isArray(data.edges) ? data.edges : [];

      if (!nodes.length) {
        showError("No data loaded. Check that data/data.js exists and is reachable.");
        return;
      }

      const nodeData = nodes.map(n => ({ ...n }));
      const nodeMap = new Map(nodeData.map(n => [n.id, n]));

      const chart = document.getElementById("chart");
      chart.innerHTML = "";
      const baseWidth = chart.clientWidth;
      const height = chart.clientHeight;

      const rawFamilies = new Set(nodeData.map(n => (n.tradition_family || "Other").trim()).filter(Boolean));
      const laneOrder = [
        "Presbyterian",
        "Reformed",
        "Baptist",
        "Methodist",
        "Lutheran",
        "Anglican",
        "Pentecostal",
        "Holiness",
        "Restorationist",
        "Adventist",
        "Catholic",
        "Other"
      ];
      const lanes = laneOrder.filter(f => rawFamilies.has(f)).concat(
        Array.from(rawFamilies).filter(f => !laneOrder.includes(f)).sort()
      );

      const laneWidth = 260;
      const chartPadding = 140;
      const desiredWidth = Math.max(baseWidth, lanes.length * laneWidth + chartPadding * 2);
      chart.style.width = `${desiredWidth}px`;
      const width = desiredWidth;

      const svg = d3.select(chart)
        .append("svg")
        .attr("width", width)
        .attr("height", height);

      const g = svg.append("g");

      const years = nodes
        .map(n => n.start_year)
        .filter(y => typeof y === "number" && !Number.isNaN(y))
        .sort((a, b) => a - b);
      const minYear = years.length ? years[0] : 0;
      const maxYear = years.length ? years[years.length - 1] : minYear;
      const bucket = 25;
      const startTick = Math.floor(minYear / bucket) * bucket;
      const endTick = Math.ceil(maxYear / bucket) * bucket;
      const yearTicks = [];
      for (let y = startTick; y <= endTick; y += bucket) {
        yearTicks.push(y);
      }

      const yScale = d3.scaleLinear()
        .domain([startTick, endTick])
        .range([60, height - 40]);

      g.selectAll(".grid")
        .data(yearTicks)
        .enter()
        .append("line")
        .attr("class", "grid")
        .attr("x1", 40)
        .attr("x2", width - 20)
        .attr("y1", d => yScale(d))
        .attr("y2", d => yScale(d))
        .attr("stroke", "var(--grid)")
        .attr("stroke-width", 1);

      const axis = document.getElementById("y-axis");
      axis.innerHTML = "";
      axis.style.height = `${height}px`;
      axis.style.top = `${chart.offsetTop}px`;
      const axisSvg = d3.select(axis)
        .append("svg")
        .attr("width", 60)
        .attr("height", height);

      const axisGroup = axisSvg.append("g");

      axisGroup.selectAll(".grid-label")
        .data(yearTicks)
        .enter()
        .append("text")
        .attr("class", "grid-label")
        .attr("x", 6)
        .attr("y", d => yScale(d) - 6)
        .attr("fill", "var(--muted)")
        .attr("font-size", 11)
        .text(d => d);

      function bucketForYear(year) {
        if (typeof year !== "number" || Number.isNaN(year)) {
          return yearTicks[0];
        }
        return yearTicks.find(y => year >= y && year < y + bucket) || yearTicks[yearTicks.length - 1];
      }

      const laneIndex = new Map(lanes.map((name, idx) => [name, idx]));
      const laneGroups = new Map();

      nodeData.forEach(n => {
        const family = (n.tradition_family || "Other").trim() || "Other";
        n._lane = laneIndex.has(family) ? family : "Other";
        n._bucket = bucketForYear(n.start_year);
        const key = `${n._lane}|${n._bucket}`;
        if (!laneGroups.has(key)) laneGroups.set(key, []);
        laneGroups.get(key).push(n);
      });

      laneGroups.forEach(group => {
        group.sort((a, b) => {
          const ay = typeof a.start_year === "number" ? a.start_year : 0;
          const by = typeof b.start_year === "number" ? b.start_year : 0;
          return ay - by || (a.name || "").localeCompare(b.name || "");
        });
      });

      nodeData.forEach(n => {
        const idx = laneIndex.get(n._lane);
        const laneCenter = chartPadding + laneWidth * idx + laneWidth / 2;
        const year = typeof n.start_year === "number" ? n.start_year : minYear;
        n.y = yScale(year);
        n.x = laneCenter - 95;
      });

      laneGroups.forEach(group => {
        if (group.length <= 1) return;
        const idx = laneIndex.get(group[0]._lane);
        const laneCenter = chartPadding + laneWidth * idx + laneWidth / 2;
        const maxSpan = laneWidth - 40;
        const spacing = Math.max(70, Math.min(180, maxSpan / (group.length - 1)));
        group.forEach((n, i) => {
          const offset = (i - (group.length - 1) / 2) * spacing;
          n.x = laneCenter + offset - 95;
        });
      });

      const links = edges
        .map(e => ({ ...e, source: nodeMap.get(e.from_id), target: nodeMap.get(e.to_id) }))
        .filter(e => e.source && e.target);

      function edgeColor(edge) {
        if (edge.type === "merge" || edge.type === "origin" || edge.type === "continuation") return "#2b6cb0";
        if (edge.type === "split") return "#6b46c1";
        return "var(--edge)";
      }

      const link = g.selectAll(".link")
        .data(links)
        .enter()
        .append("path")
        .attr("class", "link")
        .attr("fill", "none")
        .attr("stroke", d => edgeColor(d))
        .attr("stroke-width", 2)
        .attr("d", d => {
          const sx = d.source.x + 60;
          const sy = d.source.y;
          const tx = d.target.x + 60;
          const ty = d.target.y;
          const mx = (sx + tx) / 2;
          return `M ${sx} ${sy} C ${mx} ${sy}, ${mx} ${ty}, ${tx} ${ty}`;
        });

      link.each(function(d) {
        d._pathEl = this;
      });

      const edgeLabels = g.selectAll(".edge-label")
        .data(links)
        .enter()
        .append("text")
        .attr("class", "edge-label")
        .attr("font-size", 12)
        .attr("fill", "var(--muted)")
        .attr("text-anchor", "middle")
        .attr("x", d => (d.source.x + d.target.x) / 2 + 60)
        .attr("y", d => (d.source.y + d.target.y) / 2 - 6)
        .text(d => d.name || "");

      const node = g.selectAll(".node")
        .data(nodeData)
        .enter()
        .append("g")
        .attr("class", "node")
        .attr("transform", d => `translate(${d.x}, ${d.y})`);

      node.append("rect")
        .attr("width", 190)
        .attr("height", 44)
        .attr("rx", 8)
        .attr("ry", 8)
        .attr("fill", "var(--node-fill)")
        .attr("stroke", "var(--node-stroke)")
        .attr("stroke-width", 1.2);

      node.append("text")
        .attr("x", 8)
        .attr("y", 18)
        .attr("font-size", 13)
        .attr("fill", "var(--ink)")
        .text(d => {
          return d.short_label ? `${d.short_label} (${d.start_year || "?"})` : (d.name || "");
        });

      node.append("text")
        .attr("x", 8)
        .attr("y", 34)
        .attr("font-size", 11)
        .attr("fill", "var(--muted)")
        .text(d => d.name || "");

      const tooltip = document.getElementById("tooltip");

      node.on("mousemove", (event, d) => {
        tooltip.innerHTML = buildNodeTooltip(d);
        tooltip.style.display = "block";
        tooltip.style.left = `${event.clientX + 12}px`;
        tooltip.style.top = `${event.clientY + 12}px`;
      }).on("mouseleave", () => {
        tooltip.style.display = "none";
      });

      function showEdgeTooltip(event, d) {
        const target = d.target || {};
        const source = d.source || {};
        tooltip.innerHTML = buildEdgeTooltip(d, source, target);
        tooltip.style.display = "block";
        tooltip.style.left = `${event.clientX + 12}px`;
        tooltip.style.top = `${event.clientY + 12}px`;
      }

      function hideEdgeTooltip() {
        tooltip.style.display = "none";
      }

      link.on("mousemove", (event, d) => {
        showEdgeTooltip(event, d);
        d3.select(event.currentTarget).attr("stroke", "var(--edge-hover)");
      }).on("mouseleave", (event, d) => {
        hideEdgeTooltip();
        d3.select(event.currentTarget).attr("stroke", edgeColor(d));
      });

      edgeLabels.on("mousemove", (event, d) => {
        showEdgeTooltip(event, d);
        if (d._pathEl) {
          d3.select(d._pathEl).attr("stroke", "var(--edge-hover)");
        }
      }).on("mouseleave", (event, d) => {
        hideEdgeTooltip();
        if (d && d._pathEl) {
          d3.select(d._pathEl).attr("stroke", edgeColor(d));
        }
      });

      edgeLabels.raise();

      const zoom = d3.zoom()
        .scaleExtent([0.4, 2.2])
        .on("zoom", (event) => {
          g.attr("transform", event.transform);
          axisGroup.attr("transform", `translate(0, ${event.transform.y}) scale(1, ${event.transform.k})`);
        });

      svg.call(zoom);

      const zoomIn = document.getElementById("zoom-in");
      const zoomOut = document.getElementById("zoom-out");
      const zoomReset = document.getElementById("zoom-reset");

      zoomIn.addEventListener("click", () => {
        svg.transition().call(zoom.scaleBy, 1.2);
      });
      zoomOut.addEventListener("click", () => {
        svg.transition().call(zoom.scaleBy, 0.8);
      });
      zoomReset.addEventListener("click", () => {
        svg.transition().call(zoom.transform, d3.zoomIdentity);
      });
    }

    const dataScript = document.createElement("script");
    dataScript.src = `data/data.js?v=${Date.now()}`;
    dataScript.onload = () => {
      if (!window.CHURCHTREE_DATA) {
        showError("Loaded data/data.js, but window.CHURCHTREE_DATA is missing.");
        return;
      }
      renderGraph(window.CHURCHTREE_DATA);
    };
    dataScript.onerror = () => {
      const expected = new URL("data/data.js", window.location.href).href;
      showError(`Failed to load data/data.js. Expected at ${expected}`);
    };
    document.head.appendChild(dataScript);
  </script>
</body>
</html>
